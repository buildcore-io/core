import {
  CollectionType,
  MediaStatus,
  Network,
  Nft,
  NftAccess,
  NftAvailable,
  NftStatus,
  PropStats,
  UnsoldMintingOptions,
} from '@buildcore/interfaces';
import { Converter } from '../../interfaces/common';
import { PgNft } from '../../models';
import { removeNulls } from '../common';
import { pgDateToTimestamp } from '../postgres';

export class NftConverter implements Converter<Nft, PgNft> {
  toPg = (nft: Nft): PgNft => ({
    uid: nft.uid,
    project: nft.project,
    createdOn: nft.createdOn?.toDate(),
    updatedOn: nft.updatedOn?.toDate(),
    createdBy: nft.createdBy,
    name: nft.name,
    description: nft.description,
    collection: nft.collection,
    owner: nft.owner,
    isOwned: nft.isOwned,
    media: nft.media,
    ipfsMedia: nft.ipfsMedia,
    ipfsMetadata: nft.ipfsMetadata,
    ipfsRoot: nft.ipfsRoot,
    saleAccess: nft.saleAccess,
    saleAccessMembers: nft.saleAccessMembers,
    available: nft.available,
    availableFrom: nft.availableFrom?.toDate(),
    auctionFrom: nft.auctionFrom?.toDate(),
    auctionTo: nft.auctionTo?.toDate(),
    extendedAuctionTo: nft.extendedAuctionTo?.toDate(),
    auctionHighestBid: nft.auctionHighestBid || 0,
    auctionHighestBidder: nft.auctionHighestBidder || '',
    price: nft.price,
    totalTrades: nft.totalTrades,
    lastTradedOn: nft.lastTradedOn?.toDate(),
    availablePrice: nft.availablePrice || 0,
    auctionFloorPrice: nft.auctionFloorPrice || 0,
    auctionLength: nft.auctionLength || 0,
    extendedAuctionLength: nft.extendedAuctionLength || 0,
    extendAuctionWithin: nft.extendAuctionWithin || 0,
    type: nft.type,
    space: nft.space,
    url: nft.url,
    approved: nft.approved,
    rejected: nft.rejected,
    properties: nft.properties ? (JSON.stringify(nft.properties) as any) : undefined,
    stats: nft.stats ? (JSON.stringify(nft.stats) as any) : undefined,
    placeholderNft: nft.placeholderNft,
    position: nft.position,
    locked: nft.locked,
    lockedBy: nft.lockedBy || '',
    sold: nft.sold,
    mintingData_address: nft.mintingData?.address,
    mintingData_network: nft.mintingData?.network,
    mintingData_mintedOn: nft.mintingData?.mintedOn?.toDate(),
    mintingData_mintedBy: nft.mintingData?.mintedBy,
    mintingData_blockId: nft.mintingData?.blockId,
    mintingData_nftId: nft.mintingData?.nftId,
    mintingData_storageDeposit: nft.mintingData?.storageDeposit,
    mintingData_aliasBlockId: nft.mintingData?.aliasBlockId,
    mintingData_aliasId: nft.mintingData?.aliasId,
    mintingData_aliasStorageDeposit: nft.mintingData?.aliasStorageDeposit,
    mintingData_mintingOrderId: nft.mintingData?.mintingOrderId,
    mintingData_nftsToMint: nft.mintingData?.nftsToMint,
    mintingData_nftMediaToUpload: nft.mintingData?.nftMediaToUpload,
    mintingData_nftMediaToPrepare: nft.mintingData?.nftMediaToPrepare,
    mintingData_unsoldMintingOptions: nft.mintingData?.unsoldMintingOptions,
    mintingData_newPrice: nft.mintingData?.newPrice,
    mintingData_nftsStorageDeposit: nft.mintingData?.nftsStorageDeposit,
    depositData_address: nft.depositData?.address,
    depositData_network: nft.depositData?.network,
    depositData_mintedOn: nft.depositData?.mintedOn?.toDate(),
    depositData_mintedBy: nft.depositData?.mintedBy,
    depositData_blockId: nft.depositData?.blockId,
    depositData_nftId: nft.depositData?.nftId,
    depositData_storageDeposit: nft.depositData?.storageDeposit,
    depositData_aliasBlockId: nft.depositData?.aliasBlockId,
    depositData_aliasId: nft.depositData?.aliasId,
    depositData_aliasStorageDeposit: nft.depositData?.aliasStorageDeposit,
    depositData_mintingOrderId: nft.depositData?.mintingOrderId,
    depositData_nftsToMint: nft.depositData?.nftsToMint,
    depositData_nftMediaToUpload: nft.depositData?.nftMediaToUpload,
    depositData_nftMediaToPrepare: nft.depositData?.nftMediaToPrepare,
    depositData_unsoldMintingOptions: nft.depositData?.unsoldMintingOptions,
    depositData_newPrice: nft.depositData?.newPrice,
    depositData_nftsStorageDeposit: nft.depositData?.nftsStorageDeposit,
    status: nft.status,
    hidden: nft.hidden,
    mediaStatus: nft.mediaStatus,
    mediaUploadErrorCount: nft.mediaUploadErrorCount,
    soldOn: nft.soldOn?.toDate(),
    setAsAvatar: nft.setAsAvatar,
    auction: nft.auction || undefined,
  });

  fromPg = (nft: PgNft): Nft =>
    removeNulls({
      uid: nft.uid,
      project: nft.project,
      createdOn: pgDateToTimestamp(nft.createdOn),
      updatedOn: pgDateToTimestamp(nft.updatedOn),
      createdBy: nft.createdBy || '',
      name: nft.name || '',
      description: nft.description || '',
      collection: nft.collection || '',
      owner: nft.owner,
      isOwned: nft.isOwned,
      media: nft.media || '',
      ipfsMedia: nft.ipfsMedia || '',
      ipfsMetadata: nft.ipfsMetadata || '',
      ipfsRoot: nft.ipfsRoot || '',
      saleAccess: nft.saleAccess as NftAccess,
      saleAccessMembers: nft.saleAccessMembers,
      available: nft.available as NftAvailable,
      availableFrom: pgDateToTimestamp(nft.availableFrom) || null,
      auctionFrom: pgDateToTimestamp(nft.auctionFrom) || null,
      auctionTo: pgDateToTimestamp(nft.auctionTo),
      extendedAuctionTo: pgDateToTimestamp(nft.extendedAuctionTo),
      auctionHighestBid: nft.auctionHighestBid,
      auctionHighestBidder: nft.auctionHighestBidder,
      price: nft.price || 0,
      totalTrades: nft.totalTrades || 0,
      lastTradedOn: pgDateToTimestamp(nft.lastTradedOn) || null,
      availablePrice: nft.availablePrice,
      auctionFloorPrice: nft.auctionFloorPrice,
      auctionLength: nft.auctionLength,
      extendedAuctionLength: nft.extendedAuctionLength,
      extendAuctionWithin: nft.extendAuctionWithin,
      type: nft.type as CollectionType,
      space: nft.space || '',
      url: nft.url || '',
      approved: nft.approved || false,
      rejected: nft.rejected || false,
      properties: nft.properties as unknown as PropStats,
      stats: nft.stats as unknown as PropStats,
      placeholderNft: nft.placeholderNft || false,
      locked: nft.locked,
      lockedBy: nft.lockedBy,
      sold: nft.sold,
      mintingData: {
        address: nft.mintingData_address,
        network: nft.mintingData_network as Network,
        mintedOn: pgDateToTimestamp(nft.mintingData_mintedOn),
        mintedBy: nft.mintingData_mintedBy,
        blockId: nft.mintingData_blockId,
        nftId: nft.mintingData_nftId,
        storageDeposit: nft.mintingData_storageDeposit,
        aliasBlockId: nft.mintingData_aliasBlockId,
        aliasId: nft.mintingData_aliasId,
        aliasStorageDeposit: nft.mintingData_aliasStorageDeposit,
        mintingOrderId: nft.mintingData_mintingOrderId,
        nftsToMint: nft.mintingData_nftsToMint,
        nftMediaToUpload: nft.mintingData_nftMediaToUpload,
        nftMediaToPrepare: nft.mintingData_nftMediaToPrepare,
        unsoldMintingOptions: nft.mintingData_unsoldMintingOptions as UnsoldMintingOptions,
        newPrice: nft.mintingData_newPrice,
        nftsStorageDeposit: nft.mintingData_nftsStorageDeposit,
      },
      depositData: nft.depositData_address
        ? {
            address: nft.depositData_address,
            network: nft.depositData_network as Network,
            mintedOn: pgDateToTimestamp(nft.depositData_mintedOn),
            mintedBy: nft.depositData_mintedBy,
            blockId: nft.depositData_blockId,
            nftId: nft.depositData_nftId,
            storageDeposit: nft.depositData_storageDeposit,
            aliasBlockId: nft.depositData_aliasBlockId,
            aliasId: nft.depositData_aliasId,
            aliasStorageDeposit: nft.depositData_aliasStorageDeposit,
            mintingOrderId: nft.depositData_mintingOrderId,
            nftsToMint: nft.depositData_nftsToMint,
            nftMediaToUpload: nft.depositData_nftMediaToUpload,
            nftMediaToPrepare: nft.depositData_nftMediaToPrepare,
            unsoldMintingOptions: nft.depositData_unsoldMintingOptions as UnsoldMintingOptions,
            newPrice: nft.depositData_newPrice,
            nftsStorageDeposit: nft.depositData_nftsStorageDeposit,
          }
        : undefined,
      status: nft.status as NftStatus,
      mediaStatus: nft.mediaStatus as MediaStatus,
      mediaUploadErrorCount: nft.mediaUploadErrorCount,
      soldOn: pgDateToTimestamp(nft.soldOn),
      setAsAvatar: nft.setAsAvatar,
      auction: nft.auction,
      position: nft.position!,
      hidden: nft.hidden,
    });
}
