import {
  Access,
  MediaStatus,
  Network,
  Token,
  TokenAllocation,
  TokenStatus,
} from '@build-5/interfaces';
import { Converter } from '../../interfaces/common';
import { PgToken } from '../../models';
import { removeNulls } from '../common';
import { pgDateToTimestamp } from '../postgres';

export class TokenConverter implements Converter<Token, PgToken> {
  toPg = (token: Token): PgToken => ({
    uid: token.uid,
    project: token.project,
    createdOn: token.createdOn?.toDate(),
    updatedOn: token.updatedOn?.toDate(),
    createdBy: token.createdBy,

    name: token.name,
    symbol: token.symbol,
    title: token.title,
    description: token.description,
    shortDescriptionTitle: token.shortDescriptionTitle,
    shortDescription: token.shortDescription,
    space: token.space,
    pricePerToken: token.pricePerToken,
    totalSupply: token.totalSupply,
    allocations: JSON.stringify(token.allocations) as any,
    saleStartDate: token.saleStartDate?.toDate(),
    saleLength: token.saleLength,
    coolDownEnd: token.coolDownEnd?.toDate(),
    autoProcessAt100Percent: token.autoProcessAt100Percent,
    approved: token.approved,
    rejected: token.rejected,
    public: token.public,
    links: token.links?.map((u) => u.toString()),
    icon: token.icon,
    overviewGraphics: token.overviewGraphics,
    status: token.status,
    totalDeposit: token.totalDeposit,
    tokensOrdered: token.tokensOrdered,
    totalAirdropped: token.totalAirdropped,
    termsAndConditions: token.termsAndConditions,
    access: token.access,
    accessAwards: token.accessAwards,
    accessCollections: token.accessCollections,
    ipfsMedia: token.ipfsMedia,
    ipfsMetadata: token.ipfsMetadata,
    ipfsRoot: token.ipfsRoot,
    mintingData_mintedBy: token.mintingData?.mintedBy,
    mintingData_mintedOn: token.mintingData?.mintedOn?.toDate(),
    mintingData_aliasBlockId: token.mintingData?.aliasBlockId,
    mintingData_aliasId: token.mintingData?.aliasId,
    mintingData_aliasStorageDeposit: token.mintingData?.aliasStorageDeposit,
    mintingData_tokenId: token.mintingData?.tokenId,
    mintingData_blockId: token.mintingData?.blockId,
    mintingData_foundryStorageDeposit: token.mintingData?.foundryStorageDeposit,
    mintingData_network: token.mintingData?.network,
    mintingData_networkFormat: token.mintingData?.networkFormat,
    mintingData_vaultAddress: token.mintingData?.vaultAddress,
    mintingData_tokensInVault: token.mintingData?.tokensInVault,
    mintingData_vaultStorageDeposit: token.mintingData?.vaultStorageDeposit,
    mintingData_guardianStorageDeposit: token.mintingData?.guardianStorageDeposit,
    mintingData_meltedTokens: token.mintingData?.meltedTokens,
    mintingData_circulatingSupply: token.mintingData?.circulatingSupply,
    rankCount: token.rankCount,
    rankSum: token.rankSum,
    rankAvg: token.rankAvg,
    mediaStatus: token.mediaStatus,
    mediaUploadErrorCount: token.mediaUploadErrorCount,
    tradingDisabled: token.tradingDisabled,
    decimals: token.decimals,
    votes_upvotes: token.votes?.upvotes,
    votes_downvotes: token.votes?.downvotes,
    votes_voteDiff: token.votes?.voteDiff,
  });

  fromPg = (pg: PgToken): Token =>
    removeNulls({
      uid: pg.uid,
      project: pg.project,
      createdOn: pgDateToTimestamp(pg.createdOn),
      updatedOn: pgDateToTimestamp(pg.updatedOn),
      createdBy: pg.createdBy || '',

      name: pg.name || '',
      symbol: pg.symbol || '',
      title: pg.title,
      description: pg.description,
      shortDescriptionTitle: pg.shortDescriptionTitle,
      shortDescription: pg.shortDescription,
      space: pg.space,
      pricePerToken: pg.pricePerToken || 0,
      totalSupply: pg.totalSupply || 0,
      allocations: pg.allocations as unknown as TokenAllocation[],
      saleStartDate: pgDateToTimestamp(pg.saleStartDate),
      saleLength: pg.saleLength,
      coolDownEnd: pgDateToTimestamp(pg.coolDownEnd),
      autoProcessAt100Percent: pg.autoProcessAt100Percent,
      approved: pg.approved || false,
      rejected: pg.rejected || false,
      public: pg.public,
      links: (pg.links || []).map((l) => new URL(l)),
      icon: pg.icon,
      overviewGraphics: pg.overviewGraphics,
      status: (pg.status as TokenStatus)!,
      totalDeposit: pg.totalDeposit || 0,
      tokensOrdered: pg.tokensOrdered,
      totalAirdropped: pg.totalAirdropped || 0,
      termsAndConditions: pg.termsAndConditions || '',
      access: pg.access as Access,
      accessAwards: pg.accessAwards,
      accessCollections: pg.accessCollections,
      ipfsMedia: pg.ipfsMedia,
      ipfsMetadata: pg.ipfsMetadata,
      ipfsRoot: pg.ipfsRoot,
      mintingData: {
        mintedBy: pg.mintingData_mintedBy,
        mintedOn: pgDateToTimestamp(pg.mintingData_mintedOn),
        aliasBlockId: pg.mintingData_aliasBlockId,
        aliasId: pg.mintingData_aliasId,
        aliasStorageDeposit: pg.mintingData_aliasStorageDeposit,
        tokenId: pg.mintingData_tokenId,
        blockId: pg.mintingData_blockId,
        foundryStorageDeposit: pg.mintingData_foundryStorageDeposit,
        network: pg.mintingData_network as Network,
        networkFormat: pg.mintingData_networkFormat as Network,
        vaultAddress: pg.mintingData_vaultAddress,
        tokensInVault: pg.mintingData_tokensInVault,
        vaultStorageDeposit: pg.mintingData_vaultStorageDeposit,
        guardianStorageDeposit: pg.mintingData_guardianStorageDeposit,
        meltedTokens: pg.mintingData_meltedTokens,
        circulatingSupply: pg.mintingData_circulatingSupply,
      },
      rankCount: pg.rankCount,
      rankSum: pg.rankSum,
      rankAvg: pg.rankAvg,
      mediaStatus: pg.mediaStatus as MediaStatus,
      mediaUploadErrorCount: pg.mediaUploadErrorCount,
      tradingDisabled: pg.tradingDisabled,
      votes: {
        upvotes: pg.votes_upvotes || 0,
        downvotes: pg.votes_downvotes || 0,
        voteDiff: pg.votes_voteDiff || 0,
      },
      decimals: pg.decimals || 0,
    });
}
