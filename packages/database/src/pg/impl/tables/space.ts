import { MediaStatus, Network, Space } from '@buildcore/interfaces';
import { Converter } from '../../interfaces/common';
import { PgSpace } from '../../models';
import { removeNulls } from '../common';
import { pgDateToTimestamp } from '../postgres';

export class SpaceConverter implements Converter<Space, PgSpace> {
  toPg = (space: Space): PgSpace => ({
    uid: space.uid,
    project: space.project,
    createdOn: space.createdOn?.toDate(),
    updatedOn: space.updatedOn?.toDate(),
    createdBy: space.createdBy,
    name: space.name,
    about: space.about,
    open: space.open,
    tokenBased: space.tokenBased,
    minStakedValue: space.minStakedValue,
    github: space.github,
    twitter: space.twitter,
    discord: space.discord,
    avatarUrl: space.avatarUrl,
    bannerUrl: space.bannerUrl,
    totalGuardians: space.totalGuardians,
    totalMembers: space.totalMembers,
    totalPendingMembers: space.totalPendingMembers,
    smrAddress: (space.validatedAddress || {})[Network.SMR],
    rmsAddress: (space.validatedAddress || {})[Network.RMS],
    iotaAddress: (space.validatedAddress || {})[Network.IOTA],
    atoiAddress: (space.validatedAddress || {})[Network.ATOI],
    prevValidatedAddresses: space.prevValidatedAddresses || [],
    vaultAddress: space.vaultAddress,
    collectionId: space.collectionId,
    claimed: space.claimed,
    ipfsMedia: space.ipfsMedia,
    ipfsMetadata: space.ipfsMetadata,
    ipfsRoot: space.ipfsRoot,
    mediaStatus: space.mediaStatus,
    mediaUploadErrorCount: space.mediaUploadErrorCount,
    alias_address: space.alias?.address,
    alias_aliasId: space.alias?.aliasId,
    alias_blockId: space.alias?.blockId,
    alias_mintedOn: space.alias?.mintedOn?.toDate(),
    alias_mintedBy: space.alias?.mintedBy,
  });

  fromPg = (pg: PgSpace): Space =>
    removeNulls({
      uid: pg.uid,
      project: pg.project,
      createdOn: pgDateToTimestamp(pg.createdOn),
      updatedOn: pgDateToTimestamp(pg.updatedOn),
      createdBy: pg.createdBy || '',
      name: pg.name,
      about: pg.about,
      open: pg.open,
      tokenBased: pg.tokenBased,
      minStakedValue: pg.minStakedValue,
      github: pg.github,
      twitter: pg.twitter,
      discord: pg.discord,
      avatarUrl: pg.avatarUrl,
      bannerUrl: pg.bannerUrl,
      totalGuardians: pg.totalGuardians || 0,
      totalMembers: pg.totalMembers || 0,
      totalPendingMembers: pg.totalPendingMembers || 0,
      validatedAddress: {
        [Network.SMR]: pg.smrAddress || '',
        [Network.RMS]: pg.rmsAddress || '',
        [Network.IOTA]: pg.iotaAddress || '',
        [Network.ATOI]: pg.atoiAddress || '',
      },
      prevValidatedAddresses: pg.prevValidatedAddresses,
      vaultAddress: pg.vaultAddress,
      collectionId: pg.collectionId,
      claimed: pg.claimed,
      ipfsMedia: pg.ipfsMedia,
      ipfsMetadata: pg.ipfsMetadata,
      ipfsRoot: pg.ipfsRoot,
      mediaStatus: pg.mediaStatus as MediaStatus,
      mediaUploadErrorCount: pg.mediaUploadErrorCount,
      members: {},
      guardians: {},
      alias: {
        address: pg.alias_address || '',
        aliasId: pg.alias_aliasId || '',
        blockId: pg.alias_blockId || '',
        mintedOn: pgDateToTimestamp(pg.alias_mintedOn)!,
        mintedBy: pg.alias_mintedBy || '',
      },
    });
}
