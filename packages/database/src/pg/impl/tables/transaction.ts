import {
  CreditPaymentReason,
  Entity,
  IgnoreWalletReason,
  NativeToken,
  Network,
  NftBulkOrder,
  SendToManyTargets,
  StakeType,
  StorageReturn,
  Transaction,
  TransactionPayloadType,
  TransactionType,
  TransactionValidationType,
  UnsoldMintingOptions,
} from '@buildcore/interfaces';
import { Converter } from '../../interfaces/common';
import { PgTransaction } from '../../models';
import { removeNulls } from '../common';
import { pgDateToTimestamp } from '../postgres';

export class TransactionConverter implements Converter<Transaction, PgTransaction> {
  toPg = (trx: Transaction): PgTransaction => ({
    uid: trx.uid,
    project: trx.project,
    createdOn: trx.createdOn?.toDate(),
    updatedOn: trx.updatedOn?.toDate(),
    createdBy: trx.createdBy,

    network: trx.network,
    type: trx.type,
    isOrderType: trx.isOrderType,
    member: trx.member,
    space: trx.space,
    shouldRetry: trx.shouldRetry,
    ignoreWallet: trx.ignoreWallet,
    linkedTransactions: trx.linkedTransactions,
    ignoreWalletReason: trx.ignoreWalletReason || undefined,
    payload_type: trx.payload.type,
    payload_amount: trx.payload.amount || 0,
    payload_sourceAddress: trx.payload.sourceAddress || '',
    payload_targetAddress: trx.payload.targetAddress || '',
    payload_targetAddresses: JSON.stringify(trx.payload.targetAddresses) as any,
    payload_sourceTransaction: trx.payload.sourceTransaction || [],
    payload_validationType: trx.payload.validationType,
    payload_expiresOn: trx.payload.expiresOn?.toDate(),
    payload_reconciled: trx.payload.reconciled,
    payload_void: trx.payload.void,
    payload_collection: trx.payload.collection || undefined,
    payload_unsoldMintingOptions: trx.payload.unsoldMintingOptions,
    payload_newPrice: trx.payload.newPrice,
    payload_collectionStorageDeposit: trx.payload.collectionStorageDeposit,
    payload_nftsStorageDeposit: trx.payload.nftsStorageDeposit,
    payload_aliasStorageDeposit: trx.payload.aliasStorageDeposit,
    payload_nftsToMint: trx.payload.nftsToMint,
    payload_transaction: trx.payload.transaction,
    payload_unlockedBy: trx.payload.unlockedBy,
    payload_beneficiary: trx.payload.beneficiary,
    payload_beneficiaryUid: trx.payload.beneficiaryUid,
    payload_beneficiaryAddress: trx.payload.beneficiaryAddress,
    payload_royaltiesFee: trx.payload.royaltiesFee,
    payload_royaltiesSpace: trx.payload.royaltiesSpace,
    payload_royaltiesSpaceAddress: trx.payload.royaltiesSpaceAddress,
    payload_chainReference: trx.payload.chainReference || undefined,
    payload_nft: trx.payload.nft || undefined,
    payload_restrictions: JSON.stringify(trx.payload.restrictions) as any,
    payload_token: trx.payload.token,
    payload_quantity: trx.payload.quantity,
    payload_tokenSymbol: trx.payload.tokenSymbol,
    payload_unclaimedAirdrops: trx.payload.unclaimedAirdrops,
    payload_totalAirdropCount: trx.payload.totalAirdropCount,
    payload_tokenId: trx.payload.tokenId,
    payload_foundryStorageDeposit: trx.payload.foundryStorageDeposit,
    payload_vaultStorageDeposit: trx.payload.vaultStorageDeposit,
    payload_guardianStorageDeposit: trx.payload.guardianStorageDeposit,
    payload_tokensInVault: trx.payload.tokensInVault,
    payload_orderId: trx.payload.orderId,
    payload_collectionOutputAmount: trx.payload.collectionOutputAmount,
    payload_aliasOutputAmount: trx.payload.aliasOutputAmount,
    payload_nftOutputAmount: trx.payload.nftOutputAmount,
    payload_aliasId: trx.payload.aliasId,
    payload_aliasBlockId: trx.payload.aliasBlockId,
    payload_aliasGovAddress: trx.payload.aliasGovAddress,
    payload_collectionId: trx.payload.collectionId || undefined,
    payload_nftId: trx.payload.nftId || undefined,
    payload_nativeTokens: JSON.stringify(
      trx.payload.nativeTokens?.map((nt) => ({ ...nt, amount: Number(nt.amount) })),
    ) as any,
    payload_previousOwnerEntity: trx.payload.previousOwnerEntity,
    payload_previousOwner: trx.payload.previousOwner,
    payload_ownerEntity: trx.payload.ownerEntity,
    payload_owner: trx.payload.owner,
    payload_royalty: trx.payload.royalty,
    payload_vestingAt: trx.payload.vestingAt?.toDate(),
    payload_customMetadata: JSON.stringify(trx.payload.customMetadata) as any,
    payload_stake: trx.payload.stake,
    payload_award: trx.payload.award || undefined,
    payload_legacyAwardFundRequestId: trx.payload.legacyAwardFundRequestId,
    payload_legacyAwardsBeeingFunded: trx.payload.legacyAwardsBeeingFunded,
    payload_weeks: trx.payload.weeks,
    payload_stakeType: trx.payload.stakeType,
    payload_count: trx.payload.count,
    payload_price: trx.payload.price,
    payload_tokenReward: trx.payload.tokenReward,
    payload_edition: trx.payload.edition,
    payload_participatedOn: trx.payload.participatedOn?.toDate(),
    payload_proposalId: trx.payload.proposalId,
    payload_voteValues: trx.payload.voteValues,
    payload_storageDepositSourceAddress: trx.payload.storageDepositSourceAddress,
    payload_storageReturn: JSON.stringify(trx.payload.storageReturn) as any,
    payload_airdropId: trx.payload.airdropId,
    payload_nfts: trx.payload.nfts,
    payload_tag: trx.payload.tag,
    payload_metadata: JSON.stringify(trx.payload.metadata) as any,
    payload_response: JSON.stringify(trx.payload.response) as any,
    payload_reason: trx.payload.reason,
    payload_invalidPayment: trx.payload.invalidPayment,
    payload_outputToConsume: trx.payload.outputToConsume,
    payload_dependsOnBillPayment: trx.payload.dependsOnBillPayment,
    payload_milestoneTransactionPath: trx.payload.milestoneTransactionPath,
    payload_tokenAmount: trx.payload.tokenAmount,
    payload_weight: trx.payload.weight,
    payload_weightMultiplier: trx.payload.weightMultiplier,
    payload_votes: trx.payload.votes,
    payload_creditId: trx.payload.creditId,
    payload_outputConsumed: trx.payload.outputConsumed,
    payload_outputConsumedOn: trx.payload.outputConsumedOn?.toDate(),
    payload_stakes: trx.payload.stakes,
    payload_stakeReward: trx.payload.stakeReward,
    payload_tanglePuchase: trx.payload.tanglePuchase,
    payload_disableWithdraw: trx.payload.disableWithdraw,
    payload_lockCollectionNft: trx.payload.lockCollectionNft,
    payload_stamp: trx.payload.stamp,
    payload_tokenTradeOderTargetAddress: trx.payload.tokenTradeOderTargetAddress,
    payload_auction: trx.payload.auction,
    payload_days: trx.payload.days,
    payload_dailyCost: trx.payload.dailyCost,
    payload_nftOrders: JSON.stringify(trx.payload.nftOrders) as any,
    payload_swap: trx.payload.swap,
    payload_outputId: trx.payload.outputId,
    payload_walletReference_createdOn: trx.payload.walletReference?.createdOn?.toDate(),
    payload_walletReference_processedOn: trx.payload.walletReference?.processedOn?.toDate(),
    payload_walletReference_chainReference:
      trx.payload.walletReference?.chainReference || undefined,
    payload_walletReference_chainReferences: trx.payload.walletReference?.chainReferences,
    payload_walletReference_error: trx.payload.walletReference?.error as string,
    payload_walletReference_confirmed: trx.payload.walletReference?.confirmed,
    payload_walletReference_confirmedOn: trx.payload.walletReference?.confirmedOn?.toDate(),
    payload_walletReference_milestoneTransactionPath:
      trx.payload.walletReference?.milestoneTransactionPath,
    payload_walletReference_count: trx.payload.walletReference?.count,
    payload_walletReference_inProgress: trx.payload.walletReference?.inProgress,
    payload_walletReference_nodeIndex: trx.payload.walletReference?.nodeIndex,
    payload_values: trx.payload.values,
  });

  fromPg = (pg: PgTransaction): Transaction =>
    removeNulls({
      uid: pg.uid,
      project: pg.project,
      createdOn: pgDateToTimestamp(pg.createdOn),
      updatedOn: pgDateToTimestamp(pg.updatedOn),
      createdBy: pg.createdBy || '',
      network: pg.network as Network,
      type: pg.type as TransactionType,
      isOrderType: pg.isOrderType,
      member: pg.member,
      space: pg.space,
      shouldRetry: pg.shouldRetry,
      ignoreWallet: pg.ignoreWallet,
      linkedTransactions: pg.linkedTransactions,
      ignoreWalletReason: pg.ignoreWalletReason as IgnoreWalletReason,
      payload: {
        type: pg.payload_type as TransactionPayloadType,
        amount: pg.payload_amount,
        sourceAddress: pg.payload_sourceAddress,
        targetAddress: pg.payload_targetAddress,
        targetAddresses: pg.payload_targetAddresses as SendToManyTargets[] | undefined,
        sourceTransaction: pg.payload_sourceTransaction,
        validationType: pg.payload_validationType as TransactionValidationType,
        expiresOn: pgDateToTimestamp(pg.payload_expiresOn),
        reconciled: pg.payload_reconciled,
        void: pg.payload_void,
        collection: pg.payload_collection,
        unsoldMintingOptions: pg.payload_unsoldMintingOptions as UnsoldMintingOptions,
        newPrice: pg.payload_newPrice,
        collectionStorageDeposit: pg.payload_collectionStorageDeposit,
        nftsStorageDeposit: pg.payload_nftsStorageDeposit,
        aliasStorageDeposit: pg.payload_aliasStorageDeposit,
        nftsToMint: pg.payload_nftsToMint,
        transaction: pg.payload_transaction,
        unlockedBy: pg.payload_unlockedBy,
        beneficiary: pg.payload_beneficiary as Entity,
        beneficiaryUid: pg.payload_beneficiaryUid,
        beneficiaryAddress: pg.payload_beneficiaryAddress,
        royaltiesFee: pg.payload_royaltiesFee,
        royaltiesSpace: pg.payload_royaltiesSpace,
        royaltiesSpaceAddress: pg.payload_royaltiesSpaceAddress,
        chainReference: pg.payload_chainReference,
        nft: pg.payload_nft,
        restrictions: pg.payload_restrictions as any,
        token: pg.payload_token,
        quantity: pg.payload_quantity,
        tokenSymbol: pg.payload_tokenSymbol,
        unclaimedAirdrops: pg.payload_unclaimedAirdrops,
        totalAirdropCount: pg.payload_totalAirdropCount,
        tokenId: pg.payload_tokenId,
        foundryStorageDeposit: pg.payload_foundryStorageDeposit,
        vaultStorageDeposit: pg.payload_vaultStorageDeposit,
        guardianStorageDeposit: pg.payload_guardianStorageDeposit,
        tokensInVault: pg.payload_tokensInVault,
        orderId: pg.payload_orderId,
        collectionOutputAmount: pg.payload_collectionOutputAmount,
        aliasOutputAmount: pg.payload_aliasOutputAmount,
        nftOutputAmount: pg.payload_nftOutputAmount,
        aliasId: pg.payload_aliasId,
        aliasBlockId: pg.payload_aliasBlockId,
        aliasGovAddress: pg.payload_aliasGovAddress,
        collectionId: pg.payload_collectionId,
        nftId: pg.payload_nftId,
        nativeTokens: pg.payload_nativeTokens as NativeToken[] | undefined,
        previousOwnerEntity: pg.payload_previousOwnerEntity as Entity,
        previousOwner: pg.payload_previousOwner,
        ownerEntity: pg.payload_ownerEntity as Entity,
        owner: pg.payload_owner,
        royalty: pg.payload_royalty,
        vestingAt: pgDateToTimestamp(pg.payload_vestingAt),
        customMetadata: pg.payload_customMetadata as { [key: string]: string } | undefined,
        stake: pg.payload_stake,
        award: pg.payload_award,
        legacyAwardFundRequestId: pg.payload_legacyAwardFundRequestId,
        legacyAwardsBeeingFunded: pg.payload_legacyAwardsBeeingFunded,
        weeks: pg.payload_weeks,
        stakeType: pg.payload_stakeType as StakeType,
        count: pg.payload_count,
        price: pg.payload_price,
        tokenReward: pg.payload_tokenReward,
        edition: pg.payload_edition,
        participatedOn: pgDateToTimestamp(pg.payload_participatedOn),
        proposalId: pg.payload_proposalId,
        voteValues: pg.payload_voteValues,
        storageDepositSourceAddress: pg.payload_storageDepositSourceAddress,
        storageReturn: pg.payload_storageReturn as StorageReturn | undefined,
        airdropId: pg.payload_airdropId,
        outputId: pg.payload_outputId,
        walletReference: {
          createdOn: pgDateToTimestamp(pg.payload_walletReference_createdOn)!,
          processedOn: pgDateToTimestamp(pg.payload_walletReference_processedOn)!,
          chainReference: pg.payload_walletReference_chainReference,
          chainReferences: pg.payload_walletReference_chainReferences,
          error: pg.payload_walletReference_error,
          confirmed: pg.payload_walletReference_confirmed || false,
          confirmedOn: pgDateToTimestamp(pg.payload_walletReference_confirmedOn),
          milestoneTransactionPath: pg.payload_walletReference_milestoneTransactionPath,
          count: pg.payload_walletReference_count || 0,
          inProgress: pg.payload_walletReference_inProgress,
          nodeIndex: pg.payload_walletReference_nodeIndex,
        },
        nfts: pg.payload_nfts,
        tag: pg.payload_tag,
        metadata: pg.payload_metadata as any,
        response: pg.payload_response as any,
        reason: pg.payload_reason as CreditPaymentReason,
        invalidPayment: pg.payload_invalidPayment,
        outputToConsume: pg.payload_outputToConsume,
        dependsOnBillPayment: pg.payload_dependsOnBillPayment,
        milestoneTransactionPath: pg.payload_milestoneTransactionPath,
        values: pg.payload_values,
        tokenAmount: pg.payload_tokenAmount,
        weight: pg.payload_weight,
        weightMultiplier: pg.payload_weightMultiplier,
        votes: pg.payload_votes,
        creditId: pg.payload_creditId,
        outputConsumed: pg.payload_outputConsumed,
        outputConsumedOn: pgDateToTimestamp(pg.payload_outputConsumedOn),
        stakes: pg.payload_stakes,
        stakeReward: pg.payload_stakeReward,
        tanglePuchase: pg.payload_tanglePuchase,
        disableWithdraw: pg.payload_disableWithdraw,
        lockCollectionNft: pg.payload_lockCollectionNft,
        stamp: pg.payload_stamp,
        tokenTradeOderTargetAddress: pg.payload_tokenTradeOderTargetAddress,
        auction: pg.payload_auction,
        days: pg.payload_days,
        dailyCost: pg.payload_dailyCost,
        nftOrders: pg.payload_nftOrders as NftBulkOrder[] | undefined,
        swap: pg.payload_swap,
      },
    });
}
